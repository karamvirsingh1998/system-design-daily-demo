<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dependency Injection: Constructor Injection vs. Setter Injection</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #333;
            margin-bottom: 20px;
            font-size: 2.5em;
            border-bottom: 3px solid #667eea;
            padding-bottom: 15px;
        }
        .explanation {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            font-size: 1.1em;
            line-height: 1.8;
            color: #555;
        }
        h2 {
            color: #667eea;
            margin-top: 30px;
            margin-bottom: 15px;
        }
        .components-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .component-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            transition: transform 0.3s, box-shadow 0.3s;
            cursor: pointer;
        }
        .component-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }
        .steps-container {
            margin: 20px 0;
        }
        .step {
            background: #f0f0f0;
            margin: 10px 0;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            transition: all 0.3s;
            cursor: pointer;
            position: relative;
            overflow: hidden;
        }
        .step:hover {
            background: #e8e8e8;
            transform: translateX(5px);
        }
        .step.active {
            background: #e3e8ff;
            border-left-color: #764ba2;
        }
        .step-number {
            display: inline-block;
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            text-align: center;
            line-height: 30px;
            margin-right: 15px;
            font-weight: bold;
        }
        .diagram-container {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 15px;
            margin: 30px 0;
            border: 2px solid #667eea;
            min-height: 400px;
            position: relative;
        }
        #diagramCanvas {
            width: 100%;
            height: 400px;
            border-radius: 10px;
        }
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-size: 1em;
            cursor: pointer;
            margin: 0 10px;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        button:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        button:active {
            transform: scale(0.98);
        }
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #eee;
            color: #999;
        }
        .info-badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            margin: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Dependency Injection: Constructor Injection vs. Setter Injection</h1>
        <div class="explanation">Dependency Injection (DI) is a design pattern used to implement IoC (Inversion of Control), allowing for the decoupling of components in software systems. It promotes code maintainability and testability by injecting dependencies into classes rather than instantiating them within the class itself. Two common methods of DI are Constructor Injection, where dependencies are provided through a class constructor, and Setter Injection, where dependencies are set through setter methods after the object is constructed.</div>
        
        <h2>Key Components</h2>
        <div class="components-grid">
            <div class="component-card"><strong>Service Interface - Defines the contract for services.</strong></div><div class="component-card"><strong>Concrete Service - Implementation of the Service Interface.</strong></div><div class="component-card"><strong>Client - The class that depends on the Service Interface.</strong></div><div class="component-card"><strong>Dependency Injector - Responsible for providing the required dependencies.</strong></div>
        </div>
        
        <h2>How It Works</h2>
        <div class="steps-container" id="stepsContainer">
            <div class="step" data-step="0"><span class="step-number">1</span>1. Define a Service Interface that outlines the services required by the Client.</div><div class="step" data-step="1"><span class="step-number">2</span>2. Implement the Service Interface with one or more Concrete Services.</div><div class="step" data-step="2"><span class="step-number">3</span>3. Create the Client class that will use the Service.</div><div class="step" data-step="3"><span class="step-number">4</span>4. For Constructor Injection, pass the Concrete Service as a parameter to the Client's constructor.</div><div class="step" data-step="4"><span class="step-number">5</span>5. For Setter Injection, create a setter method in the Client to accept the Concrete Service after instantiation.</div><div class="step" data-step="5"><span class="step-number">6</span>6. Use a Dependency Injector to construct the Client and provide the necessary Concrete Service.</div><div class="step" data-step="6"><span class="step-number">7</span>7. The Client can now use the injected service without being tightly coupled to its implementation.</div>
        </div>
        
        <h2>Interactive Diagram</h2>
        <div class="controls">
            <button onclick="animateDiagram()">Animate Flow</button>
            <button onclick="resetDiagram()">Reset</button>
            <button onclick="highlightStep()">Highlight Current Step</button>
        </div>
        <div class="diagram-container">
            <canvas id="diagramCanvas"></canvas>
        </div>
        
        <div class="footer">
            Generated on 2026-01-11 15:56:15
        </div>
    </div>
    
    <script>
        const diagramData = {"nodes": [{"id": "serviceInterface", "label": "Service Interface", "type": "server"}, {"id": "concreteService", "label": "Concrete Service", "type": "server"}, {"id": "clientConstructor", "label": "Client (Constructor Injection)", "type": "client"}, {"id": "clientSetter", "label": "Client (Setter Injection)", "type": "client"}, {"id": "dependencyInjector", "label": "Dependency Injector", "type": "server"}], "connections": [{"from": "serviceInterface", "to": "concreteService", "label": "implements"}, {"from": "concreteService", "to": "clientConstructor", "label": "constructor injection"}, {"from": "concreteService", "to": "clientSetter", "label": "setter injection"}, {"from": "dependencyInjector", "to": "clientConstructor", "label": "creates with constructor injection"}, {"from": "dependencyInjector", "to": "clientSetter", "label": "creates with setter injection"}], "flow_direction": "top-to-bottom"};
        const stepsData = ["1. Define a Service Interface that outlines the services required by the Client.", "2. Implement the Service Interface with one or more Concrete Services.", "3. Create the Client class that will use the Service.", "4. For Constructor Injection, pass the Concrete Service as a parameter to the Client's constructor.", "5. For Setter Injection, create a setter method in the Client to accept the Concrete Service after instantiation.", "6. Use a Dependency Injector to construct the Client and provide the necessary Concrete Service.", "7. The Client can now use the injected service without being tightly coupled to its implementation."];
        const canvas = document.getElementById('diagramCanvas');
        const ctx = canvas.getContext('2d');
        let animationFrame = null;
        let currentStep = 0;
        let animationTime = 0;
        
        // Set canvas size
        function resizeCanvas() {
            canvas.width = canvas.offsetWidth;
            canvas.height = 400;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Node positions and states
        let nodes = [];
        let connections = diagramData.connections || [];
        const nodeRadius = 40;
        const nodeColors = {
            'server': '#667eea',
            'client': '#48bb78',
            'database': '#f56565',
            'cache': '#ed8936',
            'queue': '#9f7aea',
            'default': '#718096'
        };
        
        // Initialize node positions
        function initNodes() {
            const nodes_data = diagramData.nodes || [];
            const flowDir = diagramData.flow_direction || 'left-to-right';
            const cols = Math.ceil(Math.sqrt(nodes_data.length));
            const rows = Math.ceil(nodes_data.length / cols);
            
            nodes = nodes_data.map((node, i) => {
                let x, y;
                if (flowDir === 'left-to-right') {
                    x = 150 + (i % cols) * 200;
                    y = 100 + Math.floor(i / cols) * 150;
                } else {
                    x = 100 + (i % cols) * 180;
                    y = 150 + Math.floor(i / cols) * 120;
                }
                return {
                    ...node,
                    x: x,
                    y: y,
                    highlighted: false,
                    pulse: 0
                };
            });
        }
        
        // Draw diagram
        function drawDiagram(highlightedNode = null, animatedConn = null) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw connections
            connections.forEach((conn, i) => {
                const fromNode = nodes.find(n => n.id === conn.from);
                const toNode = nodes.find(n => n.id === conn.to);
                if (!fromNode || !toNode) return;
                
                const isAnimated = animatedConn === i;
                ctx.strokeStyle = isAnimated ? '#764ba2' : '#cbd5e0';
                ctx.lineWidth = isAnimated ? 3 : 2;
                ctx.beginPath();
                ctx.moveTo(fromNode.x, fromNode.y);
                ctx.lineTo(toNode.x, toNode.y);
                ctx.stroke();
                
                // Draw arrow
                const angle = Math.atan2(toNode.y - fromNode.y, toNode.x - fromNode.x);
                const arrowX = toNode.x - (nodeRadius + 5) * Math.cos(angle);
                const arrowY = toNode.y - (nodeRadius + 5) * Math.sin(angle);
                ctx.fillStyle = isAnimated ? '#764ba2' : '#cbd5e0';
                ctx.beginPath();
                ctx.moveTo(arrowX, arrowY);
                ctx.lineTo(arrowX - 10 * Math.cos(angle - Math.PI/6), arrowY - 10 * Math.sin(angle - Math.PI/6));
                ctx.lineTo(arrowX - 10 * Math.cos(angle + Math.PI/6), arrowY - 10 * Math.sin(angle + Math.PI/6));
                ctx.closePath();
                ctx.fill();
            });
            
            // Draw nodes
            nodes.forEach(node => {
                const isHighlighted = highlightedNode === node.id || node.highlighted;
                const color = nodeColors[node.type] || nodeColors.default;
                const pulse = node.pulse || 0;
                
                // Outer glow for highlighted
                if (isHighlighted) {
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = color;
                } else {
                    ctx.shadowBlur = 0;
                }
                
                // Draw node
                ctx.fillStyle = color;
                ctx.beginPath();
                const radius = nodeRadius + pulse * 5;
                ctx.arc(node.x, node.y, radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw border
                ctx.strokeStyle = isHighlighted ? '#764ba2' : '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Draw label
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(node.label, node.x, node.y);
            });
        }
        
        // Animate diagram
        function animateDiagram() {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
            }
            
            let connIndex = 0;
            function animate() {
                drawDiagram(null, connIndex);
                connIndex = (connIndex + 1) % connections.length;
                animationFrame = setTimeout(() => {
                    animationFrame = requestAnimationFrame(animate);
                }, 1000);
            }
            animate();
            
            // Stop after 5 seconds
            setTimeout(() => {
                if (animationFrame) {
                    cancelAnimationFrame(animationFrame);
                    animationFrame = null;
                }
                drawDiagram();
            }, 5000);
        }
        
        // Reset diagram
        function resetDiagram() {
            if (animationFrame) {
                cancelAnimationFrame(animationFrame);
                animationFrame = null;
            }
            nodes.forEach(n => {
                n.highlighted = false;
                n.pulse = 0;
            });
            currentStep = 0;
            drawDiagram();
        }
        
        // Highlight step
        function highlightStep() {
            const stepElement = document.querySelector(`.step[data-step="${currentStep}"]`);
            if (stepElement) {
                document.querySelectorAll('.step').forEach(s => s.classList.remove('active'));
                stepElement.classList.add('active');
                
                // Pulse effect on nodes
                nodes.forEach(n => {
                    n.pulse = 0;
                });
                
                let pulseCount = 0;
                const pulseInterval = setInterval(() => {
                    nodes.forEach(n => {
                        n.pulse = Math.sin(pulseCount * 0.5) * 3;
                    });
                    drawDiagram();
                    pulseCount++;
                    if (pulseCount > 20) {
                        clearInterval(pulseInterval);
                        nodes.forEach(n => {
                            n.pulse = 0;
                        });
                        drawDiagram();
                    }
                }, 50);
                
                currentStep = (currentStep + 1) % stepsData.length;
            }
        }
        
        // Step click handlers
        document.querySelectorAll('.step').forEach((stepEl, i) => {
            stepEl.addEventListener('click', () => {
                currentStep = i;
                highlightStep();
            });
        });
        
        // Component card click handlers
        document.querySelectorAll('.component-card').forEach((card, i) => {
            card.addEventListener('click', () => {
                if (i < nodes.length) {
                    nodes[i].highlighted = !nodes[i].highlighted;
                    drawDiagram();
                }
            });
        });
        
        // Initialize
        initNodes();
        drawDiagram();
    </script>
</body>
</html>